import React, { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import { generateClient } from "aws-amplify/data";
import "../design/Todo.css"; // Assuming this is your CSS file

// Define types for comments and video data
interface Comment {
  id: string;
  content: string;
  category: string;
  likes: number;
  dislikes: number;
  isDone: boolean;
  createdAt: string;
}

interface VideoData {
  embed_url: string;
  title: string;
}

const client = generateClient();

const CategoryPage: React.FC = () => {
  const { category } = useParams<{ category: string }>();
  const decodedCategory = decodeURIComponent(category || "");
  const [comments, setComments] = useState<Comment[]>([]);
  const [videoData, setVideoData] = useState<VideoData | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Fetch comments from DynamoDB
  useEffect(() => {
    client.models.Note.list()
      .then((data) => setComments(data.data ?? []))
      .catch((err) => {
        console.error("Error fetching comments:", err);
        setError("Failed to load comments");
      });
  }, []);

  // Fetch video from Lambda
  useEffect(() => {
    const queries: { [key: string]: string } = {
      "Business & IT Services":
        '"how to" "business tutorial" "step by step" productivity -trailer -webinar -live -promo -shorts -vlog',
      "Relationships & Lifestyle":
        '"how to" "Lifestyle" "step by step" "relationships" "personal growth" -trailer -webinar -live -promo -shorts -vlog',
      "Innovative Tech Projects":
        '"tech project" "how to" "build" "innovation" -trailer -webinar -live -promo -shorts -vlog',
      "Creative Arts & Design":
        '"beauty tutorial" "hair style" "nails" "art design" "productivity" -trailer -webinar -live -promo -shorts -vlog',
    };
    const query = queries[decodedCategory] || queries["Business & IT Services"];

    fetch(
      `https://ps4nh4qfs1.execute-api.us-east-1.amazonaws.com/dev?category=${encodeURIComponent(
        decodedCategory
      )}&query=${encodeURIComponent(query)}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": "AIzaSyABnqnNIHB2MdGcjb1N43_iA9V0SBt0Aok",
        },
      }
    )
      .then((response) => {
        if (!response.ok)
          throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
        return response.json();
      })
      .then((data: VideoData | { error: string }) => {
        console.log("Video Data:", data);
        if ("error" in data) throw new Error(data.error);
        setVideoData(data as VideoData);
        setError(null);
      })
      .catch((error: Error) => {
        console.error("Video fetch error:", error.message);
        setError(error.message || "Failed to fetch video");
      });
  }, [decodedCategory]);

  const filteredComments = comments.filter(
    (comment) => comment.category === decodedCategory
  );

  function isNewComment(lastChangedAt: string): boolean {
    if (!lastChangedAt) return false;
    const currentTime = new Date().getTime();
    const commentTime = new Date(lastChangedAt).getTime();
    return currentTime - commentTime < 2 * 60 * 1000; // 2 minutes
  }

  function createComment(): void {
    const content = window.prompt("Enter a new comment:");
    if (!content) return;

    const newComment: Comment = {
      id: "", // Assuming id is generated by the backend
      content,
      category: decodedCategory,
      likes: 0,
      dislikes: 0,
      isDone: false,
      createdAt: new Date().toISOString(),
    };

    client.models.Note.create(newComment)
      .then(() => {
        setComments((prevComments) => [...prevComments, newComment]);
        console.log("New comment created");
      })
      .catch((error: Error) => {
        console.error("Error creating comment:", error);
        setError("Failed to create comment");
      });
  }

  function updateComment(id: string, changes: Partial<Comment>): void {
    client.models.Note.update({ id, ...changes })
      .then(() => client.models.Note.list())
      .then((data) => setComments(data.data ?? []))
      .catch((error: Error) => {
        console.error("Error updating comment:", error);
        setError("Failed to update comment");
      });
  }

  function deleteComment(id: string, likes: number, dislikes: number): void {
    if (dislikes > likes) {
      client.models.Note.delete({ id })
        .then(() =>
          setComments((prev) => prev.filter((comment) => comment.id !== id))
        )
        .catch((error: Error) => {
          console.error("Error deleting comment:", error);
          setError("Failed to delete comment");
        });
    } else {
      alert("Cannot delete: dislikes must be greater than likes.");
    }
  }

  return (
    <main className="todo-container">
      {/* Video Section */}
      {error ? (
        <div className="text-center text-red-600 p-6">Error: {error}</div>
      ) : !videoData ? (
        <div className="text-center text-gray-600 p-6">Loading video...</div>
      ) : (
        <div className="mt-6">
          <h2 className="text-2xl font-semibold mb-4">
            Featured Video for {decodedCategory || "Default"}
          </h2>
          <div className="video-container">
            <iframe
              src={`${videoData.embed_url}?controls=1&mute=0&rel=0`}
              title={videoData.title || "Featured Video"}
              frameBorder="0"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
              allowFullScreen
              className="video-iframe"
            ></iframe>
          </div>
        </div>
      )}

      <h1>{decodedCategory} Comments</h1>
      <button className="add-btn" onClick={createComment}>
        + New
      </button>
      <ul className="todo-list">
        {filteredComments.map((comment) => (
          <li
            key={comment.id || comment.content + comment.createdAt}
            className={`todo-item ${comment.isDone ? "done" : ""}`}
          >
            <span
              className="todo-dot"
              style={{
                visibility: isNewComment(comment.createdAt)
                  ? "visible"
                  : "hidden",
              }}
            ></span>
            <span>{comment.content}</span>
            <div className="actions">
              <button
                className="likes-dislikes"
                onClick={() =>
                  updateComment(comment.id, { likes: (comment.likes || 0) + 1 })
                }
              >
                üëç {comment.likes || 0}
              </button>
              <button
                className="likes-dislikes"
                onClick={() =>
                  updateComment(comment.id, {
                    dislikes: (comment.dislikes || 0) + 1,
                  })
                }
              >
                üëé {comment.dislikes || 0}
              </button>
              <button
                onClick={() =>
                  updateComment(comment.id, { isDone: !comment.isDone })
                }
              >
                ‚úÖ
              </button>
              <button
                onClick={() =>
                  deleteComment(comment.id, comment.likes || 0, comment.dislikes || 0)
                }
              >
                ‚ùå
              </button>
            </div>
          </li>
        ))}
      </ul>
      <div className="footer">
        üéâ LL&L is live! Try adding a new comment!
      </div>
    </main>
  );
};

export default CategoryPage;